#summary Tips & Tricks: what you can do with $.jsonp()

=Tips & Tricks=

==Simple usage==

Get user profiles from YouTube
{{{
function getProfile(userId) {

    $.jsonp({
      "url": "http://gdata.youtube.com/feeds/api/users/"+userId+"?callback=?",
      "data": {
          "alt": "json-in-script"
      },
      "success": function(userProfile) {
          // handle user profile here 
      },
      "error": function(d,msg) {
          alert("Could not find user "+userId);
      }
    });
}
}}}

==Callback name is not in the url parameters==

By default, $.jsonp() uses "C" as the callback name. You then just have to put "C" where the callback name is supposed to be in the url.
{{{
"http://weird-provider.org/C/my-service?param1=1&param2=2&..."
}}}
If you find it confusing or unreadable to have a single capital C buried inside the url, you can always use the _callback_ option to use a different name and do something like this:
{{{
$.jsonp({
    url: "http://weird-provider.org/XXXXXXXX/my-service?param1=1&param2=2&...",
    callback: "XXXXXXXX",
    success: function(json) {
       // This will be called in case of success no matter the callback name
    },
    error: function() {
       // This will be called in case of error no matter the callback name
    }
});
}}}

==Provider calls a specific callback and I can't override its name in the url==

Thankfully, $.jsonp() can handle the situation and you won't have to create a function that's named after the callback and is supposed to handle every response received from this provider.

Say services of _lazy-provider.org_ all call the same callback: _lazyCallback_. All you have to do is something like this:
{{{
$.jsonp({
    url: "http://lazy-provider.org/a-service?param1=1&param2=2&...",
    callback: "lazyCallback",
    success: function(json) {
       // Will be given the response of 'a-service'
    },
    error: function() {
       // Will be notified of an error requesting 'a-service'
    }
});
$.jsonp({
    url: "http://lazy-provider.org/another-service?param1=1&param2=2&...",
    callback: "lazyCallback",
    success: function(json) {
       // Will be given the response of 'another-service'
    },
    error: function() {
       // Will be notified of an error requesting 'another-service'
    }
});
}}}
Both requests can be sent concurrently and $.jsonp() ensures that no collision will ever occur.

==How do I take advantage of the cache?==

$.jsonp handles two types of cache. One is browser based, the other is page based.

===Browser cache===

Usual JSONP implementations rely on generated callback names to allow concurrent JSONP requests. $.jsonp does not. No matter the situation, if you stick by the default behavior, the callback will always be "C". This means that the url used to perform the request is constant from one call to another for the same set of parameters. In that case, smart providers can issue a _304: Not Modified_ and allow the browser to cache the HTTP response.

This is not an exact science. YouTube, for instance, does not always issue a _304_ but when it does eventually, it means further JSONP requests will be directly taken from the cache.

To take advantage of browser caching, you have to set the _cache_ option to true. For instance:
{{{
$.jsonp({
    url: "...",
    cache: true,
    success: function(json) {
       // your success code here
    },
    error: function() {
       // error handling goes here
    }
});
}}}

===Page-based cache===

Some providers do not take in consideration the situation when the callback name has not changed. In this case, you can use the page-based cache. This cache is stored in the javascript VM memory and ensures that, when you make a request that's already been handled, you'll get the exact same answer and no network call will be made.

This cache is wiped-out as soon as the page is reloaded.

To take advantage of page-based caching, you have to set the _pageCache_ options to true. Note that doing so overiddes any setting the _cache_ option could have and sets it to true also. For instance:
{{{
$.jsonp({
    url: "...",
    pageCache: true,
    success: function(json) {
       // your success code here
    },
    error: function() {
       // error handling goes here
    }
});
}}}

==Arrays are not arrays==

Atzoum of the [http://cometdproject.dojotoolkit.org cometd] crew pointed out quite an annoying side effect due to the use of iframes within $.jsonp().

Iframes and the main window do not share constructors. For instance, if you create an array in an iframe, it is another "Array" function than the one within the main window scope that'll be used. Furthermore, it is impossible to re-route iframe constructors to their main window counterparts for security reasons.

So, if a jsonp request returns an array (let's call it myArray) and you try to confirm it is an array within your own code, myArray.constructor===Array will return false. Even worse, Internet Explorer will fail on this very statement saying myArray.constructor does not exist (or myArray.sort or any other method).

One way to work around this issue while leaving the rest of your code untouched is to serialize and deserialize the response prior to passing it to the success callback. To that end, you can make use of the JSON object within the dataFilter callback (if your browser does not provide a native JSON implementation, check the [http://www.json.org/json2.js json.org one]).

The code goes as follows:
{{{
$.jsonp({
    url: "...",
    dataFilter: function(json) {
       JSON.parse(JSON.stringify(json));
    },
    success: function(json) {
       // your success code here
    },
    error: function() {
       // error handling goes here
    }
});
}}}